<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D AI Magic 8 Ball</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Segoe+UI:wght@600&display=swap');
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background-color: #000;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #eee;
    user-select: none;
    height: 100vh;
    position: relative;
  }
  #overlay {
    position: fixed;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 90vw;
    max-width: 600px;
    text-align: center;
    z-index: 10;
    pointer-events: auto;
    cursor: text;
  }
  #question {
    font-size: 28px;
    font-weight: 600;
    width: 100%;
    max-width: 600px;
    border: none;
    border-bottom: 3px solid #666;
    background: transparent;
    color: #eee;
    outline: none;
    padding: 6px 8px;
    text-align: center;
    letter-spacing: 0.03em;
    transition: border-color 0.3s ease;
  }
  #question:focus {
    border-color: #007bffcc;
  }
  #helper {
    font-size: 14px;
    font-style: italic;
    margin-top: 8px;
    color: #666;
    user-select: none;
  }
  #overlay.disabled {
    cursor: default;
  }
</style>
</head>
<body>
  <div id="overlay">
    <input id="question" type="text" placeholder="Type your question here..." autocomplete="off" />
    <div id="helper">*press enter to ask*</div>
  </div>
  <canvas id="canvas"></canvas>

  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.min.js"></script>
  <!-- GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script>
    // Setup scene, camera, renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0.5, 6);

    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("canvas"), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);

    // Controls with damping
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.12;
    controls.minDistance = 4;
    controls.maxDistance = 10;
    controls.enablePan = false;

    // Lights
    const pointLight = new THREE.PointLight(0xffffff, 1.5);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);
    scene.add(new THREE.AmbientLight(0x222222));

    // Magic 8 Ball sphere
    const ballGeometry = new THREE.SphereGeometry(1.5, 128, 128);
    const ballMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x111111,
      metalness: 0.5,
      roughness: 0.7,
      clearcoat: 1,
      clearcoatRoughness: 0.1,
      reflectivity: 0.5,
    });
    const ball = new THREE.Mesh(ballGeometry, ballMaterial);
    scene.add(ball);

    // Front window circle (glowing)
    const windowGeometry = new THREE.CircleGeometry(0.65, 64);
    const windowMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x0022ff,
      emissive: 0x0044ff,
      emissiveIntensity: 0.5,
      roughness: 0.2,
      metalness: 0.3,
      transparent: true,
      opacity: 0.85,
      side: THREE.DoubleSide,
      clearcoat: 1,
      clearcoatRoughness: 0.1,
    });
    const ballWindow = new THREE.Mesh(windowGeometry, windowMaterial);
    ballWindow.position.z = 1.52;
    ballWindow.rotation.x = -Math.PI / 2;
    ball.add(ballWindow);

    // Internal icosahedron (the die)
    const dieGeometry = new THREE.IcosahedronGeometry(0.6);
    const dieMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x0033cc,
      metalness: 0.7,
      roughness: 0.3,
      clearcoat: 1,
      clearcoatRoughness: 0.1,
      flatShading: true,
      emissive: 0x001122,
      emissiveIntensity: 0.6
    });
    const die = new THREE.Mesh(dieGeometry, dieMaterial);
    scene.add(die);

    // Canvas texture for answer text
    const textCanvas = document.createElement('canvas');
    textCanvas.width = 512;
    textCanvas.height = 512;
    const ctx = textCanvas.getContext('2d');
    const textTexture = new THREE.CanvasTexture(textCanvas);

    const textPlaneMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true, opacity: 0 });
    const textPlane = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.2), textPlaneMaterial);
    textPlane.position.z = 1.53;
    ball.add(textPlane);

    // Draw answer on canvas texture
    function drawAnswer(text) {
      ctx.clearRect(0, 0, textCanvas.width, textCanvas.height);

      const gradient = ctx.createRadialGradient(textCanvas.width/2, textCanvas.height/2, 50, textCanvas.width/2, textCanvas.height/2, 220);
      gradient.addColorStop(0, 'rgba(0,68,255,0.8)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, textCanvas.width, textCanvas.height);

      ctx.fillStyle = 'white';
      ctx.font = 'bold 48px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(0,0,0,0.7)';
      ctx.shadowBlur = 10;
      ctx.fillText(text, textCanvas.width/2, textCanvas.height/2);

      textTexture.needsUpdate = true;
    }

    const standardAnswers = [
      "It is certain", "It is decidedly so", "Without a doubt", "Yes, definitely",
      "You may rely on it", "As I see it, yes", "Most likely", "Outlook good",
      "Yes", "Signs point to yes", "Reply hazy, try again", "Ask again later",
      "Better not tell you now", "Cannot predict now", "Concentrate and ask again",
      "Don't count on it", "My reply is no", "My sources say no",
      "Outlook not so good", "Very doubtful"
    ];

    // GSAP animate die spin with inertia easing
    function animateDie(onComplete) {
      const startRot = { x: die.rotation.x, y: die.rotation.y, z: die.rotation.z };
      const spins = 5 + Math.random() * 4; // spins count
      const targetRot = {
        x: startRot.x + Math.PI * 2 * spins * (Math.random() > 0.5 ? 1 : -1),
        y: startRot.y + Math.PI * 2 * spins * (Math.random() > 0.5 ? 1 : -1),
        z: startRot.z + Math.PI * 2 * spins * (Math.random() > 0.5 ? 1 : -1)
      };

      gsap.to(die.rotation, {
        x: targetRot.x,
        y: targetRot.y,
        z: targetRot.z,
        duration: 1.8,
        ease: "power4.inOut",
        onComplete: onComplete
      });
    }

    // Fade in answer text on the window
    function fadeInAnswer() {
      gsap.fromTo(textPlane.material, 
        { opacity: 0 }, 
        { opacity: 1, duration: 1.2, ease: "power1.inOut" }
      );
    }

    // Animate window glow pulse
    function glowPulse() {
      gsap.to(ballWindow.material, {
        emissiveIntensity: 2,
        duration: 0.5,
        yoyo: true,
        repeat: 3,
        ease: "sine.inOut"
      });
    }

    // Ask question handler
    async function askQuestion() {
      const overlay = document.getElementById('overlay');
      const questionInput = document.getElementById('question');
      const helperText = document.getElementById('helper');
      const question = questionInput.value.trim();
      if (!question) return;

      // Disable input & helper
      questionInput.disabled = true;
      helperText.style.opacity = 0;
      overlay.classList.add('disabled');

      // Animate input up top center
      gsap.to(overlay, {
        duration: 1.3,
        ease: "power2.out",
        bottom: "auto",
        top: "30px",
        onComplete: () => {
          // glow, spin, answer
          glowPulse();
          getAnswerAndAnimate(question);
        }
      });
    }

    async function getAnswerAndAnimate(question) {
      let answer = null;
      try {
        answer = await getAIAnswer(question);
        if (!answer) throw new Error("No answer");
      } catch {
        answer = standardAnswers[Math.floor(Math.random() * standardAnswers.length)];
      }

      animateDie(() => {
        drawAnswer(answer);
        fadeInAnswer();
        // Re-enable input and reset after delay
        setTimeout(() => {
          resetInput();
        }, 2500);
      });
    }

    async function getAIAnswer(question) {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer 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"
        },
        body: JSON.stringify({
          model: "gpt-4o",
          messages: [
            { role: "system", content: "You are a magic 8 ball. Only answer using short standard phrases." },
            { role: "user", content: question }
          ],
          max_tokens: 30,
          temperature: 0.8
        })
      });
      const data = await response.json();
      return data.choices?.[0]?.message?.content?.trim() || null;
    }

    // Reset input area to bottom, clear question & helper text
    function resetInput() {
      const overlay = document.getElementById('overlay');
      const questionInput = document.getElementById('question');
      const helperText = document.getElementById('helper');

      gsap.to(overlay, {
        duration: 1,
        ease: "power2.inOut",
        top: "auto",
        bottom: "60px",
        onComplete: () => {
          questionInput.value = "";
          questionInput.disabled = false;
          helperText.style.opacity = 1;
          overlay.classList.remove('disabled');
          textPlane.material.opacity = 0;
        }
      });
    }

    // Keyboard enter trigger
    document.getElementById('question').addEventListener('keydown', (e) => {
      if (e.key === "Enter") {
        askQuestion();
      }
    });

    // Render loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
